#+hugo_base_dir: ../
#+hugo_section: posts
#+hugo_weight: auto
#+startup: logdone
#+macro: imgzoom #+attr_html: :link t

* posts
** DONE Games I Want To Run :@rpg:
CLOSED: [2025-01-28 Tue 17:10]
:PROPERTIES:
:EXPORT_FILE_NAME: games_to_run
:END:
Here's a few game that I want run together with a pitch and some links for further reading.
#+TOC: headlines 1
*** [[https://www.chaosium.com/cthulhu-by-gaslight-investigators-guide-hardcover/][Call Of Cthulhu - Gaslight]]
{{{imgzoom}}}
[[file:/blog/images/coc_gaslight.webp]]

Victorian era London. Class divides are strong and discrimination is everywhere. Chuck in the horrors of Cthulhu to break down the hierarchy and everyones sanity.

Very simple to play but with lots of depth to dive into as well. You aren't meant to defeat everything you see because sometimes it's a god of unknownable horrors.

Related Media:
- Dracula
- Frankenstein
- Crimson Peak
*** [[https://shop.arcdream.com/products/delta-green-the-role-playing-game-hardback-slipcase-set?ref=delta-green.com][Delta Green]]
{{{imgzoom}}}
[[/blog/images/delta_green.png]]

The world is ending and right before calamity the good guys sweep in and save the day. You are those good guys but what does it cost your sanity to see the things you have seen.

Based on Call Of Cthulhu but modern era. Easy to play and lots of cool character building systems. You should hopefully save the world but maybe not make it out alive.

Related Media:
- X-Files
- Stranger Things
- True Detective
*** [[https://www.tuesdayknightgames.com/pages/mothership-rpg][Mothership]]
{{{imgzoom}}}
[[/blog/images/mothership.jpg]]

A crew tries (and often fails) to survive the vast expansive of space and all of the human and inhuman horrors it contains.

Simple system with very little to learn to pickup and play. But your character is very unlikely to change much and will almost certainly be dead.

Related Media:
- Alien franchise
- Underwater
- Event Horizon
*** [[https://www.drivethrurpg.com/en/product/348809/worlds-without-number-free-edition][Worlds Without Number]]
{{{imgzoom}}}
[[/blog/images/worlds_without_number.png]]

Old school fantasy swords and sorcery. Delve into dungeons, stab things and collect loot.

Sometimes called Old School Renaissance (OSR), it's tactical and often brutal so you have to think before you do things! Often battles can be over quickly with a decisive plan.

Related Media:
- Dungeons and Dragons
- Conan
- Lord of the Rings
*** [[https://www.thearcanelibrary.com/pages/shadowdark][Shadowdark]]
{{{imgzoom}}}
[[/blog/images/shadowdark.avif]]

A much more streamlined dungeon crawling adventure. Use magic, steel, and wits to delve into mysterious ruins, lost cities, and monster-infested depths. Wondrous treasures and long-forgotten secrets await you! But don't let your last torch burn out, or you could be swallowed by the Shadowdark.

Related Media:
- Same as Worlds Without Number
*** [[https://www.kickstarter.com/projects/bastionland/mythic-bastionland-rpg-before-into-the-odd][Mythic Bastionland]]
{{{imgzoom}}}
[[/blog/images/mythic_bastionland.jpg]]

Rules light roleplaying in a dreamlike world of knights and myths. Crawl hexes, rule a domain, and remember your oath.

Very Arthurian Knights roaming a kingdom, completing quests and meeting weird seers.

Related Media:
- The Green Knight
*** [[https://www.myth.works/en-gb/pages/slugblaster][Slugblaster]]
{{{imgzoom}}}
[[file:/blog/images/slugblaster.webp][file:/blog/images/slugblaster.webp]]

In the small town of Hillview, teenage hoverboarders sneak into other dimensions to explore, film tricks, go viral, and get away from the problems at home. It’s dangerous. It’s stupid. It’s got parent groups in a panic. And it’s the coolest thing ever.This is Slugblaster. A table-top rpg about teenagehood, giant bugs, circuit-bent rayguns, and trying to be cool.

** DONE On Gradient Descent :@rpg:@mothership:
CLOSED: [2025-02-04 Tue 22:12]
:PROPERTIES:
:EXPORT_FILE_NAME: gradient_descent
:END:
Here are some of my thoughts on the mothership Megadungeon [[https://www.tuesdayknightgames.com/products/gradient-descent][Gradient Descent]] as my players have just reached the end of the sixth session.
*** I get Megadungeons
Starting running RPGs with D&D 5th edition put me into a bit of a weird space. I read a lot of the critique online and just didn't understand the problems until I ran a campaign. My players spent hours creating their characters, picking out abilities and writing in some cases some really cool backstories; which immediately meant nothing. I had a story to force them down and I just kept feeling like I wasn't a good enough DM to squish together their complex creations into the pages of the book and craft something greater.

Jesus could I not have been more wrong. Yeah I suck as a DM, but 5th edition (especially their pre-written adventures) does not help you with this at all. The idea of writing characters into an existing story as you are improvising and trying to juggle what "must happen" is so difficult that I would love to see someone pull it off so I can learn from them.

Jumping into Gradient Descent felt overwhelming at first. How do I keep track of all the rooms? How the hell do you roleplay an AI that is beyond human intelligence? Will the players actually enjoy this kinda empty space station? It just works though. The structure of the megadungeon means that story develops as we play and really I barely do any prep at all between sessions and just see what my players do at the table.

The brilliant [[https://dungeons.hismajestytheworm.games/][Designing Dungeons Course]] talks about designing dungeons as an exercising in building up narrative potential energy and man does that hold up for Gradient Descent. It's full to the brim of killer robots, traps and social dilemmas that meant I had to figure out how to put all the pieces together in my head but after that it's just a case of seeing which pieces my players pick up each session.

I have been running this as a open table and it's also been brilliant to get new people sat down and rolling dice with very little fuss about anything that have missed. I think it helps that it's a single big location but also everyone knows that AI is going to destroy the human race so it's easy to get your head straight into it.
*** What are the robots in tubes?
That isn't to say it has always been easy. Gradient descent has the osr feel of sparse descriptions. Which makes it a breeze to run sure but I also found myself breezing over things that maybe would have made the game better?

A particular scene that stood out were some androids in stasis in a room the player's travelled through. It's not really clear why they are there? I guessed as a security counter measure but what sets them off? Are they just triggered by too much movement? Is this a puzzle? In my panic they stayed off as the players went through but later on they tripped an alarm so they dropped out the ceiling. But the book specifically describes security being sent from another floor.

This could just all be me getting this confused or making it more complicated than it needs to be. But I felt like I didn't get the purpose. Which to be fair to book it gets bang on in some floors where it really clearly says "these guys are religious fundamentalists, they worship monarch" which really was about that many words but it helped me to feel like I knew what the direction was.
*** I'm too nice
The main issues for sure though are me! I really need to be more brutal, especially earlier on in the campaign. I think setting the scene of "you will die here" would have helped to get the players into the osr mindset from the start. So:
- Play the rules as written (I messed up a few rules here and there that gave the players more of a chance).
- Don't be afraid of dragging the fights out
  There were so many cool three way battles going on at points and I often let the players slip away in the melee.
- Make the ending tough.
  Right now they are onto the home stretch trying to take out monarch. It makes sense that a super powerful AI in command of a space station isn't going to go down easy.

In summary the book is amazing and I'm on the megadungeon hypetrain.
** DONE Writing A Compiler In A Week
CLOSED: [2025-05-15 Thu 10:35]
:PROPERTIES:
:EXPORT_FILE_NAME: beazley_course
:END:
Writing a good compiler in a week is a pretty difficult task. Writing it in Haskell when you don't really know what you are doing is even tougher. But, thanks to the amazing course by [[https://www.dabeaz.com/][David Beazley]] I managed it! The code is [[https://github.com/oliverpauffley/wabbit_compiler][here]].

It was an amazing thing to take part in mainly just for the grind of just sitting down and coding at something for a week and by the end having a working project. Not that I just came up with everything myself. Dave does a great job of splitting up the work into mini projects so the compiler seems to just appear as you knock down the tasks. I also heavily borrowed the parsing/lexing sections from [[https://github.com/cronokirby/haskell-in-haskell][cronokirby]] which made that section significantly easier.

Out of all the code I think the section I'm most proud of is this:
#+begin_src haskell
convertInstructions :: B.INSTRUCTION -> LLVMConverter (Maybe LLVMOperation)
convertInstructions (B.PUSH i) = push (InputI i) >> return Nothing
convertInstructions B.ADD = convertBin B.ADD
convertInstructions B.MUL = convertBin B.MUL
convertInstructions B.LT = convertBin B.LT
convertInstructions B.EQ = convertBin B.EQ
convertInstructions (B.LOADGLOBAL n) = convertLoad n Global
convertInstructions (B.LOADLOCAL n) = convertLoad n Local
convertInstructions (B.STOREGLOBAL n) = convertStore n Global
convertInstructions (B.STORELOCAL n) = convertStore n Local
convertInstructions (B.CALL name numArgs) = do
  args <- replicateM numArgs pop
  register <- getRegister
  push (InputR register)
  return $ Just (Call register name args)
convertInstructions B.PRINT = do
  val <- pop
  return $ Just (Print val)
convertInstructions B.RETURN = do
  val <- pop
  return $ Just (Return val)
convertInstructions (B.LOCAL n) = return $ Just (Allocate n)
convertInstructions (B.GOTO bl) = return $ Just (Goto bl)
convertInstructions (B.CBRANCH blT blF) = do
  r <- toIResult <$> pop
  return $ Just (Branch r blT blF)
convertBin :: B.INSTRUCTION -> LLVMConverter (Maybe LLVMOperation)
convertBin op = do
  right <- pop
  left <- pop
  register <- getRegister
  push (InputR register)
  return $ Just (BinOp (convertBinOp op) register left right)
#+end_src

What does it do? Well the =LLVMConvertor= is a state monad. It is responsible for two things.
1. Tracking the current register we are going to use for some LLVM instructions.
2. Keeping a stack of "interpreter" code that we need to covert into LLVM instructions.

We have already done some preliminary transformations to make this easier. So we should be starting from something like
#+begin_src
PUSH 10
STOREGLOBAL "x"
LOADGLOBAL "x"
PUSH 1
ADD
STOREGLOBAL "x"
PUSH 23
PUSH 45
MUL
LOADGLOBAL "x"
ADD
PRINT
#+end_src

Which we need to transform into
#+begin_src
    store i32 10, i32* @x
    %.0 = load i32, i32* @x
    %.1 = add i32 %.0, 1
    store i32 %.1, i32* @x
    %.2 = mul i32 23, 45
    %.3 = load i32, i32* @x
    %.4 = add i32 %.2, %.3
    call i32 (i32) @_print_int(i32 %.4)
    ret i32 0
#+end_src

The key parts here are the register names =%.0= and that we have turned something like
#+begin_src
PUSH 23
PUSH 45
MUL
#+end_src
into
#+begin_src
%.2 = mul i32 23, 45
#+end_src

So how does the haskell work?
#+begin_src haskell
convertInstructions :: B.INSTRUCTION -> LLVMConverter (Maybe LLVMOperation)
#+end_src
Within the monad we are given an =INSTRUCTION= like "PUSH 10"
Well this needs to go into our stack within the state monad. So we just =push= onto the stack but we don't need to return a LLVM operation so the code for converting an interpreter instruction into an LLVM operation is:
#+begin_src haskell
convertInstructions :: B.INSTRUCTION -> LLVMConverter (Maybe LLVMOperation)
convertInstructions (B.PUSH i) = push (InputI i) >> return Nothing
#+end_src
Or push the number onto our stack of instructions and return nothing

Then when we get to a =MUL= instruction we already have the two numbers on our stack of instructions so we need to "pop" those off, get a new register to assign our result to and then return the operation. Getting a new register looks like this:
#+begin_src haskell
-- | gets a new register to store values and increments the counter for the next call
getRegister :: LLVMConverter IResult
getRegister = do
  LLVMState {..} <- get
  put $ LLVMState (succ _registerValue) _stack
  return _registerValue
#+end_src
So we get the current state of our register value, get it's successor with =succ= and update the value in the state. And converting an binary operation is just
#+begin_src haskell
convertBin :: B.INSTRUCTION -> LLVMConverter (Maybe LLVMOperation)
convertBin op = do
  right <- pop
  left <- pop
  register <- getRegister
  push (InputR register)
  return $ Just (BinOp (convertBinOp op) register left right)
#+end_src
Note that we need to keep track of the registers in the stack which is what the line =push (InputR register)= is doing.

I still have lots of do on this compiler and I learnt so much during the course that I would really like to just start again with the knowledge that I have now. Overall I highly recommend taking one of David's courses.
** DONE Nix for Reproducible Developer Environments
CLOSED: [2025-10-23 Thu 14:37]
:PROPERTIES:
:BEAMER_env: quotation
:END:
#+LaTeX_HEADER: \usemintedstyle{tango} \setminted{fontfamily="Mononoki Nerd Font", breaklines=true, breakanywhere=true, fontsize=\large}
#+LaTeX_CLASS_OPTIONS: [smaller,aspectratio=169]
#+BEAMER_COLOR_THEME: wolverine
#+BEAMER_HEADER: \beamerdefaultoverlayspecification{<+->}
#+options: toc:nil
*** Protobuf
#+attr_latex: :width 250px
[[./what_are_protos.png]]
*** Version Number Wars
**** Col left
:PROPERTIES:
   :BEAMER_col: 0.45
   :BEAMER_opt: [t]
   :END:
Everyone loves a PR with 2000+ changes.
[[./pr_size.png]]
**** Col right
:PROPERTIES:
   :BEAMER_col: 0.45
   :BEAMER_opt: [t]
   :END:

But drilling down.
[[./why_big.png]]
*** The Problem
Every developer has a different version of the tools used to generate the protos!
*** Make - Install everything on my machine
Lets just include instructions on how to install things
#+begin_src makefile
PROTOC_VERSION := 3.14.0
.PHONY: install-protoc
install-protoc:
	curl -OL https://github.com/protocolbuffers/protobuf/releases/download/v$(PROTOC_VERSION)/$(PROTOC_FILE)
	sudo unzip -o $(PROTOC_FILE) -d /usr/local bin/protoc
	sudo unzip -o $(PROTOC_FILE) -d /usr/local 'include/*'
	rm -f $(PROTOC_FILE)
#+end_src
# story -> technical -> lessons learnt
# interweave the story with the tech an lessons
*** Ahh?
- Turns out this was already in the repo.
- I don't really want to have curl installing things.
- You can just ignore it.
*** Install everything on someone else's machine
- If only there was a way to build a little mini machine with the binaries I need already on it.
- Distribute the machine.
- Docker!
# story -> technical -> lessons learnt
*** Docker
#+begin_src dockerfile
FROM cimg/go:1.19-node as build-stage

ENV PROTOC_VERSION=3.18.1

# Install protoc
RUN curl -LO https://github.com/protocolbuffers/protobuf/releases/download/v${PROTOC_VERSION}/protoc-${PROTOC_VERSION}-linux-x86_64.zip
RUN unzip protoc-${PROTOC_VERSION}-linux-x86_64.zip -d $HOME/.local
RUN rm protoc-${PROTOC_VERSION}-linux-x86_64.zip

RUN mkdir -p /home/circleci/project/pkg/generated

# Install go/js tooling
ADD Makefile .
ADD go.mod .
ADD go.sum .
ADD package.json .
ADD yarn.lock .
RUN make install

ADD . .
# Generate code from proto files.
RUN make protos-generate

FROM scratch as export-stage

COPY --from=build-stage /home/circleci/project/pkg/generated /pkg/generated
#+end_src
*** Docker
**** Col left
:PROPERTIES:
   :BEAMER_col: 0.45
   :BEAMER_opt: [t]
   :END:
Pros:
- We can distribute this file and get the same(ish) system for everyone
- We can use it CI/CD
**** Col right
:PROPERTIES:
   :BEAMER_col: 0.45
   :BEAMER_opt: [t]
   :END:

Cons:
- We have actually only lifted the problem into docker
- =ADD package.json=
- This is only as deterministic as the package management we are using within docker.
- Very slow
- Doesn't connect well with local tooling for devs
*** Nix - Install everything on my machine the same as everyone else's
# story -> technical -> lessons learnt
*** Demo
*** Is Nix for You?
**** Col left
:PROPERTIES:
   :BEAMER_col: 0.45
   :END:
Almost definitely no...
- It's a little complicated to learn (But really not a big barrier to entry).
- The payoff is complicated to explain.
- Error messages are difficult to understand.
But
- It's probably the future?
- When it's working and setup it's incredibly powerful.
- You are probably rebuilding it's features yourself.
**** Col right
:PROPERTIES:
   :BEAMER_col: 0.45
   :END:
#+begin_quote
I’ve been a happy Nix user for about 18 months now, and– well, not happy happy, but satisfied… no… not really satisfied either; perhaps it’s more of a resigned disgruntlement; a feeling that despite its many flaws, it’s still better than anything else out there, and I’ve invested so much time into it already that it would be a shame to give up now, so… am I describing Stockholm syndrome?
--- Ian Henry
#+end_quote
*** How to install Nix
https://nixos.org/download/

- Works on linux, mac and windows (through wsl)
- You can use it as well as your other package managers
*** Haskell Book Club
I also run a monthly haskell book club. Meeting on the last Sunday of the month
*** Questions?
